---
layout: post
title: mysql中的锁
date: 2019-05-09
---
# 表锁与行锁
行锁是指：对指定的行加锁
表锁是指：对所有的表加锁
# 锁的类型

## 共享锁(S)
所有读操作都可以获取这个锁
## 排他锁(X)
排他锁被获取后，不可以再获取共享锁。获取不可以再获取 排他锁

## 意向共享锁
> innoDb数据操作之前自动加的。不需要用户干预

表示事务准备给数据行加入共享锁，即一个数据行加共享锁前必须先取得该表的IS锁， 意向共享锁之间是可以相互兼容的
## 意向排它锁
> 意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预

表示事务准备给数据行加入排他锁，即一个数据行加排他锁前必须先取得该表的IX锁， 意向排它锁之间是可以相互兼容的

## 自增锁
针对自增列自增长的一个特殊的表级锁


# 行锁的算法
[官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks)
## Next-key locks
> 锁住记录+区间(左开右闭)

![IMAGE](http://cn-isoda-oss.yy.com/admin/video/0CCB3438658BFA3F12E5FFB10F5C051A.jpg)
当sql执行按照索引进行数据的检索时。查询条件为范围查询(between and、<、>等)，并有数据命中则这个sql就会加上net-keylocks。这样可以解决
解决行锁幻读的问题


## Gap锁

![IMAGE](http://cn-isoda-oss.yy.com/admin/video/4A7E9B870489387A22F8DE555B062F58.jpg)
当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，锁住索引不存在的区间(左开右开)


## Record locks

![IMAGE](http://cn-isoda-oss.yy.com/admin/video/428588C0B95149A18B75813ADB39EAF0.jpg)
当sql执行按照唯一性(Primary key、Unique key)索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks


# 死锁
## 死锁的条件
- 互斥条件
- 不可抢占条件
- 占有且申请条件
- 循环等待条件

## 如何避免数据库死锁
> 只要破坏这四个必要条件中的任意一个条件，死锁就不会发生。

1. 类似的业务逻辑以固定的顺序访问表和行。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择
5. 为表添加合理的索引。可以看到如果不走索引将会锁表



