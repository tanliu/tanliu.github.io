---
layout: post
title: JVM基本理论
date: 2019-04-18
tags:
   - java
   - jvm
---
java学习文档：[地址](https://docs.oracle.com/javase/specs/jls/se8/html/index.html)
# JVM简介
Java 虚拟机 Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM实现了Java语言最重要的特征：即平台无关性。原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证，同时也是 Java 程序的安全检验引擎（还进行安全检查）。

JVM 是 编译后的 Java 程序（.class文件）和硬件系统之间的接口 （ 编译后：javac 是收录于 JDK 中的 Java 语言编译器。该工具可以将后缀名为. java 的源文件编译为后缀名为. class 的可以运行于 Java 虚拟机的字节码。）

# JVM简介
![](https://user-gold-cdn.xitu.io/2019/4/22/16a455df39eae6ce?w=1426&h=922&f=png&s=444572)

     
JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area

## 类加载器
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/9D629FB380FF9BB2833082B54DBB5E15.jpg)
1. 类装载器
  ![IMAGE](http://cn-isoda-oss.yy.com/admin/video/F0F8D3C743F1AE00AC550A4E963F44A1.jpg)
  - 启动类装载器（Bootstrap Class Loader）
    - 这个类加载器被创建，它负责加载虚拟机的核心类库，如 java.lang.* 等。例如 java.lang.Object 就是由根类加载器加载的。需要注意的是，这个类加载器不是用 java 语言写的.装载核心lib
  - 扩展类装载器(Extension class loade)
    - jdk/lib/ext目录下等api
  - 系统类装载器(AppClass Loader)
    - classpath目录下的
  - 自定义类装载器
  
2. 装载器过程
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/10B3E8BEBD95BECCD1C5053E77EBBCFE.jpg)
- 装载过程：虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区（java8 无数据区）之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。

  - 网络的方式
  - 文件的方式
  - 运行时动态生成

注：数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。

- 验证：字节码等验证
- 准备：为变量分配内存，为类变量初始化(private static int size = 12的语句，初始化size=0)
- 解释：接口，方法，字段等解释
- 初始化（size=12）


3. 双亲委派
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载
- 安全性：职责分明后。指定的类指定加载器加载。







## 运行时数据区
> 橙色:线程共享
> 灰色区：线程不共享

### PC寄存器：
每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码(用来存储指向下一条指令的地址,也即将 要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内 存空间，几乎可以忽略不记。

### java栈：
在线程创建的时候就会被创建，跟随线程的生命周期，所以栈是线程私有的。只要线程结束，栈就会被回收。其中，8种数据类型的变量+对象引用变量+实例方法都是在函数的栈内存中分配。

栈存储如下：
- 栈操作：记录出栈、入栈操作
- 指向运行时常量池的引用 
- 方法出口（return）
- 动态链接

### 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
- native区这个与堆外内存有关


### 堆
新生代+老年代+方法区
新生代分为：eden+surivor+spaces
老年代：老年代
元空间

### 方法区
> 方法区是一个逻辑性的东西，永久代只是方法区的一个实现

方法区 jvm中发展：
- JDK1.6有之前：有永久代，常量池方法区
- JDK1.7: 有永久代，常量池在堆
- JDK1.8: 没有永久代，常量池在无空间中

方法区保存的信息：
- 类信息
   - 类的版本
   - 字段
   - 方法
   - 接口
- 静态变更 
- 常量
- 类信息
- 运行时常量池



### 堆与栈的交互
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/8D02BA08D1E271037C31A128A5D4A701.jpg)
1. 栈引用到java堆中获取对象实例数据。
2. java堆中拿是到方法区中获取对象类型信息。


## 执行引擎

## 栈的详解
### 栈的简介
 以上已经作了基本解释
### 栈帧
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/7312227E7A105559057A56AD8B0F064E.jpg)
局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息



### 逃逸分析与栈上分配
逃逸分析：分析对象的方式，把对象引用赋值给方法外的引用。
栈上分配：把没有逃逸的对象在栈空间上分配空间

## 问题
- 为什么可以用Object类
- java启动类是哪个
- 双亲委派与沙箱安全机制

## 对象创建
> 在对象创建需求给对象分区空间
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/95842EA4B90865EEC2FDE5F9DC2DD7DC.jpg)

- 给对象分配内存
- 线程安全性问题
- 初始化对象
- 执行构造方法

### 如何分配的对
- 指针碰撞
- 空间列表

### 线程安全问题
- 线程同步
- 本地线程分配缓冲（TLAB）

### 对象的结构
- Header信息
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/2F71F8488E035504141963C4804582FE.jpg)
  - 自身运行时的数据
    - hashCode
    - GC分代年龄
    - 锁状态标志
    - 线程持有锁
    - 偏向线程ID
    - 偏向时间戳
  - 类型指针
  - 数组长度

### 对象的访问定位
![IMAGE](http://cn-isoda-oss.yy.com/admin/video/A8CC26A22986B6E785225329B557ADD4.jpg)
- 句柄方式（内存空间，就是中间指针）
- 直接指针（HostSpot）
 - java堆中会存放访问类无数据的地址，reference存储


# 垃圾回收
## 如何判断一个对象是垃圾
1. 引用计数法: 对象中添加一个引用计数器，当被引用时就+1操作。
    - 优点：容易实现
    - 不足：性能差、无法解决双向引用的问题
   
2. 可达性分析法
   - 优点：解决双向引用的问题

## 哪些可以作为GCRoot
- 虚拟机栈
- 方法区的类属性所引用的对象
- 方法区的



## 有哪些回收算法
1. 标记清除：对于存活的标记，清理没有标记的
    - 优点：简单
    - 不足：有内存碎片
2. 复制算法（年轻代）
   minorGC会把Eden中的所有活的对象移动到servivor区，如果serviver区中放不下，剩下的活的对象会被移动到old区。
   当对象有eden出生后，再经过数年代后就进入old区
3. 标记整理
   标记存活的对象，然后把存活对象压缩到连续的内存中
   不足： 很占io

对象的创建方式
- new
- 反射
- clone







# 内存分配与回收策略
- 对象优先在eden区分配 
- 大对象直接分配到老年代
```
-verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:PretenureSizeThreshold=6M
```
- 长期存活的对象将进入才老年代
```
  -XX:MaxTenuringThreshold = 15
```
- 动态对象年龄判定
- 空间分配担保






  
